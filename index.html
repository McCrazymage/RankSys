<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <link rel="shortcut icon" href="images/favicon.ico">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>RankSys</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <img src="images/logo.png" alt = "RankSys logo" style = "float: left; margin-right: 25px; margin-top:25px; height: 150px;"/>

        <header>
          <h1>RankSys</h1>
          <h2>Java 8 Recommender Systems framework for novelty, diversity and much more</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/saulvargas/RankSys/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/saulvargas/RankSys/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/saulvargas/RankSys" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h2>
<a id="authors" class="anchor" href="#authors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Authors</h2>

<ul>
<li><a href="http://www.saulvargas.es">Saúl Vargas</a></li>
<li><a href="http://ir.ii.uam.es/castells/">Pablo Castells</a></li>
</ul>

<h2>
<a id="references" class="anchor" href="#references" aria-hidden="true"><span class="octicon octicon-link"></span></a>References</h2>

<p>If you publish research that uses RankSys, please cite the papers in the following list that best match the parts of the framework that you used:</p>

<ul>
<li>S. Vargas, L. Baltrunas, A. Karatzoglou, P. Castells. Coverage, Redundancy and Size-Awareness in Genre Diversity for Recommender Systems. 8th ACM Conference on Recommender Systems (RecSys 2014). Foster City, CA, USA, October 2014, pp. 209-216.</li>
<li>S. Vargas, P. Castells, D. Vallet. Explicit Relevance Models in Intent-Oriented Information Retrieval Diversification. 35th Annual International ACM SIGIR Conference on Research and Development in Information Retrieval (SIGIR 2012). Portland, OR, USA, August 2012, pp. 75-84.</li>
<li>S. Vargas, P. Castells. Rank and Relevance in Novelty and Diversity Metrics for Recommender Systems. 5th ACM Conference on Recommender Systems (RecSys 2011). Chicago, Illinois, October 2011, pp. 109-116.</li>
</ul>

<h2>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h2>

<p>RankSys is a new framework for the implementation and evaluation of recommendation algorithms and techniques that has resulted from the work carried out throughout the PhD thesis <a href="http://ir.ii.uam.es/saul/saulvargas-thesis.pdf">"Novelty and Diversity Evaluation and Enhancement in Recommender Systems"</a> of <a href="http://www.saulvargas.es">Saúl Vargas</a> under the supervision of <a href="http://ir.ii.uam.es/castells/">Pablo Castells</a>. While it is envisioned as a framework for the generic experimentation of recommendation technologies, it is naturally specialized in the evaluation and enhancement of novelty and diversity. RankSys receives its name because it targets explicitly the ranking task problem. We therefore do not consider the case of rating prediction as we consider that it leads to sub-optimal recommendations in terms of user satisfaction and business performance. This decision is reflected in the design of the different core interfaces and components of the framework.</p>

<p>The framework has been programmed with Java 8, which is the most recent version of the popular programming language. We take advantage of many of the new features of the language, such as the use of lambda functions, <code>Stream</code>'s and facilities for automatic parallelization of the code. The code licensed under the GPL V3, which allows the free use, study, distribution and modification of the software as long as derived works are distributed under the same license.</p>

<p>To date, the publicly available version of this framework includes the modules that implement novelty and diversity metrics and re-ranking techniques and the required core components of the framework:</p>

<ul>
<li>RankSys-core, which contains the common and auxiliary classes of the framework.</li>
<li>RankSys-metrics, which contains the interfaces and common components for defining metrics.</li>
<li>RankSys-diversity, which contains the novelty and diversity metrics and re-ranking strategies.</li>
<li>RankSys-examples, which provides examples of usage of the previous modules.</li>
</ul>

<p>In the rest of the appendix, we provide a high-level description of the different components of the current release of the software.</p>

<h2>
<a id="input-data" class="anchor" href="#input-data" aria-hidden="true"><span class="octicon octicon-link"></span></a>Input Data</h2>

<p>In the current version of RankSys we consider two types of input data: interactions between users and items - in the form of ratings, play counts, etc. - and feature information about the items - genres, language, etc. In both cases, the data can be interpreted as pairs of entities - user-item pairs and item-feature pairs, respectively - for which we may have some additional information - such as ratings, play counts or weights. In this section, we provide a description of the interfaces and classes employed to represent the input data of our recommendation platform that are part of the RankSys-core module.</p>

<p>As identified in the previous paragraph, our framework considers three different sets of entities, namely users, items and features, whose pairs define the input data of our recommendation algorithms. For each of these entities, we consider an index-like interface that allows us to keep track of its members. For example, the set of users of our system is accessed by means of classes that implement the following interface <code>UserIndex</code>:</p>

<pre><code>public interface UserIndex&lt;U&gt; {
    public boolean containsUser(U u);
    public int numUsers();
    public Stream&lt;U&gt; getAllUsers();
}
</code></pre>

<p>Analogous interfaces have been defined for the sets of items (<code>ItemIndex</code>) and features (<code>FeatureIndex</code>). In the current version, we do not provide direct implementations of these interfaces, but extend them in our input data interfaces as we describe next.</p>

<p>The interaction data between users and items, which is the main information used in collaborative filtering algorithms, is handled by means of classes implementing the interface <code>RecommenderData</code>, which extends the <code>UserIndex</code> and <code>ItemIndex</code> interfaces and adds methods to access the information regarding the interactions between users and items:</p>

<pre><code>public interface RecommenderData&lt;U, I, V&gt; extends UserIndex&lt;U&gt;,
 ItemIndex&lt;I&gt; {
    public int numUsers(I i);
    public int numItems(U u);
    public int numPreferences();
    public Stream&lt;IdValuePair&lt;I, V&gt;&gt; getUserPreferences(U u);
    public Stream&lt;IdValuePair&lt;U, V&gt;&gt; getItemPreferences(I i);
}
</code></pre>

<p>Note that the type of feedback is left as a generic type <code>V</code>, which allows to consider every type of possible feedback data such as ratings, play counts or series of timestamps. Implementations of this <code>RecommenderData</code> can be backed by in-memory structures or by a database. We provide a simple <code>SimpleRecommenderData</code> class that implements this interface by simply storing the user-item pairs in two different hash tables indexed by user and item, respectively.</p>

<p>The information about item features, which can be used by content-based recommendation algorithms or our novelty and diversity metrics and re-ranking techniques, is managed in our framework by an interface <code>FeatureData</code> similar to <code>RecommenderData</code>, which is defined as follows:</p>

<pre><code>public interface FeatureData&lt;I, F, V&gt; extends ItemIndex&lt;I&gt;,
 FeatureIndex&lt;F&gt; {
    Stream&lt;IdValuePair&lt;I, V&gt;&gt; getFeatureItems(final F f);
    Stream&lt;IdValuePair&lt;F, V&gt;&gt; getItemFeatures(final I i);
    int numFeatures(I i);
    int numItems(F f);
}
</code></pre>

<p>Analogously to the user-item data, we provide a hash table-backed implementation of this interface in the class <code>SimpleFeatureData</code>.</p>

<h2>
<a id="recommendations" class="anchor" href="#recommendations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recommendations</h2>

<p>As stated in the introduction, our framework considers ranked lists of items as the natural output of recommendation algorithms. In particular, we require the order or recommendation lists to be determined by decreasing order of a scoring function. We therefore define the class <code>Recommendation</code> that encapsulates the information about the user that receives the recommendation and a list of item-score pairs that compose the recommendation:</p>

<pre><code>public class Recommendation&lt;U, I&gt; {
    public Recommendation(U user, List&lt;IdDoublePair&lt;I&gt;&gt; items) {...}
    public U getUser() {...}
    public List&lt;IdDoublePair&lt;I&gt;&gt; getItems() {...}
}
</code></pre>

<p>In our experiments, recommendations are conveniently stored in files for later access of metrics that evaluate their accuracy, novelty or diversity. For that purpose, we include a <code>RecommendationFormat</code> interface whose implementations specify the format in which recommendations are written in and read from files:</p>

<pre><code>public interface RecommendationFormat&lt;U, I&gt; {
    ...
    public Writer&lt;U, I&gt; getWriter(OutputStream out) throws IOException;
    public interface Writer&lt;U, I&gt; extends Closeable {
        public void write(Recommendation&lt;U, I&gt; recommendation) throws
         IOException;
    }
    ...
    public Reader&lt;U, I&gt; getReader(InputStream in) throws IOException;
    public interface Reader&lt;U, I&gt; {
        public Stream&lt;Recommendation&lt;U, I&gt;&gt; readAll() throws
         IOException;
    }
}
</code></pre>

<p>As it can be observed, the <code>RecommendationFormat</code> interface is in turn composed of two different interfaces for reading and writing that have to be reciprocal, that is, the first needs to be able to read the format used by the second. We provide a <code>SimpleRecommendationFormat</code> class that implements this interface by printing in plain text files sets of recommendations as user-item-score triplets sorted by decreasing score for each user.</p>

<h2>
<a id="metrics" class="anchor" href="#metrics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Metrics</h2>

<p>The common infrastructure for metrics is defined in the RankSys-metrics module. It consists of two different interfaces for metrics and some common components for defining rank and relevance-awareness in metrics.</p>

<p>We identify two types of metrics that evaluate the output of recommendation algorithms: user-side metrics that evaluate the ability of a particular recommendation to satisfy the needs of the user that receives it, and business or system-side metrics that evaluate the overall effectiveness of a set of recommendations issued to a community of users.
For user-side metrics, implementations simply have to comply with the following <code>RecommendationMetric</code> interface:</p>

<pre><code>public interface RecommendationMetric&lt;U, I&gt; {
    public double evaluate(Recommendation&lt;U, I&gt; recommendation);
}
</code></pre>

<p>This simple interface provides a numerical value for each recommendation. Its implementations are expected to be immutable, i.e. calculating the result of a recommendation does not change the internal state of the instance of the class. This allows instances of <code>RecommendationMetric</code> to be called concurrently. As examples, we include in RankSys-metrics implementations of two widely used accuracy metrics for ranking tasks, namely precision and nDCG, which are implemented in the classes <code>Precision</code> and <code>NDCG</code>, respectively.
System-side metrics have to implement the following, mutable <code>SystemMetric</code> interface:</p>

<pre><code>public interface SystemMetric&lt;U, I&gt; {
    public void add(Recommendation&lt;U, I&gt; recommendation);
    public void combine(SystemMetric&lt;U, I&gt; other);
    public double evaluate();
    public void reset();
}
</code></pre>

<p>This interface is considerably different to the <code>RecommendationMetric</code> interface and has been designed so that the value of the metric can be computed by means of a <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#MutableReduction"><em>mutable reduction</em></a> of the recommendations provided, thus allowing the calculation of a metric for a system in a parallel fashion. As an example, we provide in RankSys-metrics a <code>AverageRecommendationMetric</code> class that calculates the average value across users of any instance of <code>RecommendationMetric</code>.</p>

<p>Additionally, the module RankSys-metrics provides generic models to take into account the ranking and relevance of the items in recommendations. The ranking model defined in the interface <code>RankingDiscountModel</code> defines a discount function based on the rank of an item in a recommendation:</p>

<pre><code>public interface RankingDiscountModel {
    public double disc(int k);
}
</code></pre>

<p>Implementations of this interface can be plugged into metrics to consider different ranking discounts. We provide four different classes that implement this interface: <code>NoDiscountModel</code> for ignoring any rank position discount, <code>LogarithmicDiscountModel</code> as in nDCG, <code>ExponentialDiscountModel</code> as in RBP and <code>ReciprocalDiscount</code> as in ERR.
The relevance model considers the perception of the users about the relevance of the recommended items. It is defined in the abstract class <code>RelevanceModel</code>, which extends an auxiliary <code>PersonalizableModel</code> class that allows the caching of the resulting user relevance models:</p>

<pre><code>public abstract class RelevanceModel&lt;U, I&gt; extends
 PersonalizableModel&lt;U&gt; {
    ...
    protected abstract UserRelevanceModel&lt;U, I&gt; get(U user);
    ...
    public interface UserRelevanceModel&lt;U, I&gt; extends UserModel&lt;U&gt; {
        public boolean isRelevant(I item);
        public double gain(I item);
    }
}
</code></pre>

<p>As it can be observed, the abstract class <code>RelevanceModel</code> defines an interface <code>UserRelevanceModel</code> that has two methods to determine whether an item is found relevant to a user and the gain that is obtained when recommending it. An extension to this interface is defined in <code>IdealRelevanceModel</code> to retrieve the set of all items that the user finds relevant, which is useful in metrics that are normalized by the maximum possible score, such as nDCG. We include in this module two instantiable relevance models: <code>NoRelevanceModel</code> to ignore the relevance of items and <code>BinRelevanceModel</code> which applies a threshold on a test partition of the user-item interaction data to determine the relevance of the recommended items. Some of the metrics provided in this module or the novelty and diversity metrics in RankSys-diversity may define their own relevance models depending on the definition of the metric they are implementing.</p>

<h2>
<a id="novelty-and-diversity" class="anchor" href="#novelty-and-diversity" aria-hidden="true"><span class="octicon octicon-link"></span></a>Novelty and Diversity</h2>

<p>The module RankSys-diversity contains our implementations of the novelty and diversity metrics and re-ranking strategies that have been implemented for this thesis. The metrics implement the interfaces defined in the module RankSys-metric, while the re-ranking methods share a common set of interfaces and classes defined in this module. In this section, we provide a description of the common re-ranking interfaces and classes and an overview of the different novelty and diversity models grouped in the different packages of the module.</p>

<h3>
<a id="re-ranking-strategies" class="anchor" href="#re-ranking-strategies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Re-ranking Strategies</h3>

<p>In this thesis we have considered the re-ranking of the output of baseline recommendation algorithms as a practical and efficient way of optimizing the novelty and diversity of recommendations. We consider two types of re-ranking: one that is the result of a direct re-scoring of the scores provided by the original recommendation ranking, and a greedy selection in which some set-wise magnitude is maximized by iteratively selection those items that maximize it. In both cases, we consider a high-level interface <code>Reranker</code> which, given an original recommendation, returns another recommendation that is a re-ranking of the first:</p>

<pre><code>public interface Reranker&lt;U, I&gt; {
    public Recommendation&lt;U, I&gt; rerankRecommendation
        (Recommendation&lt;U, I&gt; recommendation);
}
</code></pre>

<p>In our implementation, we consider an abstract class <code>PermutationReranker</code> that, rather than returning a <code>Recommendation</code> object, returns the permutation that results from the re-ranking.
The purpose of this <code>PermutationReranker</code> is to have a more compact representation of re-rankings. By saving only the permutation that defines the recommendation, we can efficiently store in disk or keep in memory many re-rankings of a single recommendation baseline.
As a direct instantiable implementation of this <code>PermutationReranker</code>, we include a <code>RandomReranker</code> which returns randomly generated permutations. Re-ranking strategies based on direct re-scoring of a recommender's output also implement directly this interface. Re-ranking methods based on greedy selection extend the abstract class <code>GreedyReranker</code>, which performs a greedy selection based on an objective function that is updated after each step of the selection. Since most of our greedy re-ranking algorithms are themselves based on a linear combination of the original recommender's scores and some novelty component, we provide an abstract <code>LambdaReranker</code> class that performs a normalized linear combination of the original scoring and the novelty component.</p>

<h3>
<a id="item-novelty-metrics-and-re-ranking-strategies" class="anchor" href="#item-novelty-metrics-and-re-ranking-strategies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Item Novelty Metrics and Re-Ranking Strategies</h3>

<p>The user-side metrics defined in Chapter 4 of the thesis - with the exception of EILD - are implemented in package <code>es.uam.eps.ir.ranksys.diversity.itemnovelty</code>. This package includes a generic <code>ItemNovelty</code> interface for personalized novelty models, which is the base for the abstract <code>ItemNoveltyMetric</code> class for metrics and the abstract <code>ItemNoveltyReranker</code> class for direct re-ranking strategies:</p>

<pre><code>public abstract class ItemNovelty&lt;U, I&gt; extends
 PersonalizableModel&lt;U&gt; {
    ...
    public UserItemNoveltyModel&lt;U, I&gt; getUserModel(U u) {...}
    public interface UserItemNoveltyModel&lt;U, I&gt; extends UserModel&lt;U&gt; {
        public double novelty(I i);
    }
}
</code></pre>

<p>In the current version of the framework, three sub-classes of <code>ItemNovelty</code> are included to represent the popularity complement (PC), free discovery (FD) and profile distance (PD) item novelty models defined in Chapter 4.</p>

<h3>
<a id="distance-based-metrics-and-re-ranking-strategies" class="anchor" href="#distance-based-metrics-and-re-ranking-strategies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Distance-Based Metrics and Re-Ranking Strategies</h3>

<p>For better readability of the code, the intra-list distance-based metrics and re-ranking algorithms of Chapter 4 do not extend from the previous item novelty model package and are separated in its own package <code>es.uam.eps.ir.ranksys.diversity.distance</code>. This package defines an <code>ItemDistanceModel</code> for considering different definitions for the distance between items:</p>

<pre><code>public interface ItemDistanceModel&lt;I&gt; {
    public double dist(I i, I j);
}
</code></pre>

<p>We include an abstract class <code>FeatureItemDistanceModel</code> that takes a <code>FeatureData</code> object to compute the distance between items by means of their features. Two distance functions based on Jaccard and cosine similarity are implemented by extending <code>FeatureItemDistanceModel</code>. On top of this distance models, the <code>EILD</code> class provides the implementation of the EILD metric and, respectively, the <code>MMR</code> class implements the corresponding re-ranking strategy.</p>

<h3>
<a id="sales-diversity-metrics" class="anchor" href="#sales-diversity-metrics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sales Diversity Metrics</h3>

<p>Rank and relevance-unware Sales Diversity metrics in Chapter 4 are implemented in the package <code>es.uam.eps.ir.ranksys.diversity.sales.metrics</code>. Since these are business-side metrics, they implement the interface <code>SystemMetric</code>. In particular, the implemented metrics are Aggregate Diversity, Entropy, Gini Index and Gini-Simpson Index. Since the three last metrics are based on the number of times each item is recommended to the community of users, they conveniently extend the abstract <code>AbstractSalesDiversityMetric</code> class that implements the count of how many items each item is recommended to users.</p>

<h3>
<a id="intent-aware-metrics-and-re-ranking-strategies" class="anchor" href="#intent-aware-metrics-and-re-ranking-strategies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Intent-Aware Metrics and Re-Ranking Strategies</h3>

<p>Our adaptation of the Intent-Aware metrics and diversification techniques in Chapter 5 is contained in the package <code>es.uam.eps.ir.ranksys.diversity.intentaware</code>. The basis of this package is the <code>IntentModel</code> class, which represents the concept of user aspect space when it is defined by item features in the user profile. This <code>IntentModel</code> is then used in the implementations of the metrics ERR-IA and α-nDCG and the xQuAD diversification method provided in this package.</p>

<h3>
<a id="binomial-metrics-and-re-ranking-strategies" class="anchor" href="#binomial-metrics-and-re-ranking-strategies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Binomial Metrics and Re-Ranking Strategies</h3>

<p>The metrics and re-ranking strategies of the Binomial framework proposed in Chapter 6 are found in package <code>es.uam.eps.ir.ranksys.diversity.binom</code>. All of them use the <code>BinomialModel</code> class, which implements the binomial probability model that defines the coverage and redundancy scores for a given recommendation list size. Metrics and re-ranking strategies for coverage, redundancy and joint diversity are included in this package.</p>

<h2>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h2>

<p>The module RankSys-examples contains two examples of use of the metrics and re-ranking strategies defined in the other modules. Together with this documentation, they should be used as a starting point to familiarize with the code in the framework. As more modules are added to the framework, additional example code will be added to this module.</p>
        </section>

        <footer>
          RankSys is maintained by <a href="https://github.com/saulvargas">Saúl Vargas</a> and <a href="http://ir.ii.uam.es/castells">Pablo Castells</a>.<br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>
